package tss

import (
	"fmt"
	"net/http"
	"sync/atomic"

	"github.com/sisu-network/tendermint/crypto"
	"github.com/sisu-network/tendermint/mempool"
	ttypes "github.com/sisu-network/tendermint/types"

	sdk "github.com/sisu-network/cosmos-sdk/types"
	"github.com/sisu-network/lib/log"
	"github.com/sisu-network/sisu/common"
	"github.com/sisu-network/sisu/config"
	"github.com/sisu-network/sisu/utils"
	"github.com/sisu-network/sisu/x/tss/keeper"
	"github.com/sisu-network/sisu/x/tss/tssclients"
	"github.com/sisu-network/sisu/x/tss/types"
)

const (
	ProposeBlockInterval = 1000
)

var (
	ErrInvalidMessageType      = fmt.Errorf("Invalid Message Type")
	ErrMessageHasBeenProcessed = fmt.Errorf("Message has been processed")
	ErrCannotFindMessage       = fmt.Errorf("Cannot find the message in node's private db")
	ErrValueDoesNotMatch       = fmt.Errorf("Value does not match")
)

// A major struct that processes complicated logic of TSS keysign and keygen. Read the documentation
// of keygen and keysign's flow before working on this.
type Processor struct {
	keeper                keeper.Keeper
	config                config.TssConfig
	tendermintPrivKey     crypto.PrivKey
	txSubmit              common.TxSubmit
	appKeys               common.AppKeys
	globalData            common.GlobalData
	partyManager          PartyManager
	txOutputProducer      TxOutputProducer
	lastContext           atomic.Value
	checkDuplicatedTxFunc mempool.PreCheckFunc
	txDecoder             sdk.TxDecoder

	// Public address of the key generated by TSS.
	keyAddress string

	// Dheart & Deyes client
	dheartClient tssclients.DheartClient
	deyesClients map[string]*tssclients.DeyesClient

	// A map of chain -> map ()
	worldState       WorldState
	keygenVoteResult map[string]map[string]bool
	keygenBlockPairs []BlockSymbolPair

	privateDb keeper.PrivateDb
}

func NewProcessor(k keeper.DefaultKeeper,
	config config.TssConfig,
	tendermintPrivKey crypto.PrivKey,
	appKeys *common.DefaultAppKeys,
	dataDir string,
	txDecoder sdk.TxDecoder,
	txSubmit common.TxSubmit,
	globalData common.GlobalData,
) *Processor {
	p := &Processor{
		keeper:            &k,
		privateDb:         keeper.NewPrivateDb(dataDir),
		txDecoder:         txDecoder,
		appKeys:           appKeys,
		config:            config,
		tendermintPrivKey: tendermintPrivKey,
		txSubmit:          txSubmit,
		globalData:        globalData,
		partyManager:      NewPartyManager(globalData),
		keygenVoteResult:  make(map[string]map[string]bool),
		// And array that stores block numbers where we should do final vote count.
		keygenBlockPairs: make([]BlockSymbolPair, 0),
		deyesClients:     make(map[string]*tssclients.DeyesClient),
	}

	return p
}

func (p *Processor) Init() {
	log.Info("Initializing TSS Processor...")

	log.Debug("Index = ", p.config.Index)

	go func() {
		p.runServer()
	}()

	p.txOutputProducer = NewTxOutputProducer(p.worldState, p.keeper, p.appKeys, p.privateDb, p.config)
}

func (p *Processor) runServer() {
	root := func(w http.ResponseWriter, req *http.Request) {
		fmt.Fprintf(w, "hello\n")

		p.txSubmit.SubmitMessage(types.NewTestMessage(p.appKeys.GetSignerAddress().String(), p.config.Index, 0))
		// p.txSubmit.SubmitMessage(types.NewTestMessage(p.appKeys.GetSignerAddress().String(), p.config.Index, 1))
	}

	http.HandleFunc("/", root)

	http.ListenAndServe(":7070", nil)
}

func (p *Processor) BeginBlock(ctx sdk.Context, blockHeight int64) {
	fmt.Println("At BEGIN block", ctx.BlockHeight())

	p.setContext(ctx)
}

func (p *Processor) EndBlock(ctx sdk.Context) {
	fmt.Println("At END block", ctx.BlockHeight())
}

func (p *Processor) CheckTx(ctx sdk.Context, msgs []sdk.Msg) error {
	for _, msg := range msgs {
		if msg.Route() != types.ModuleName {
			return fmt.Errorf("Some message is not a TSS message")
		}

		log.Info("Checking tx: Msg type = ", msg.Type())

		switch msg.(type) {
		case *types.KeygenWithSigner:
			return p.checkKeygen(ctx, msg.(*types.KeygenWithSigner))

		case *types.KeygenResultWithSigner:
			return p.checkKeygenResult(ctx, msg.(*types.KeygenResultWithSigner))

		case *types.TxInWithSigner:
			return p.checkTxIn(ctx, msg.(*types.TxInWithSigner))

		case *types.TxOutWithSigner:
			return p.checkTxOut(ctx, msg.(*types.TxOutWithSigner))

		case *types.KeysignResult:
			return p.checkKeysignResult(ctx, msg.(*types.KeysignResult))

		case *types.ContractsWithSigner:
			return p.checkContracts(ctx, msg.(*types.ContractsWithSigner))

		case *types.TxOutConfirmWithSigner:
			return p.checkTxOutConfirm(ctx, msg.(*types.TxOutConfirmWithSigner))

		case *types.TestMessage:
			return p.checkTxTestMessage(ctx, msg.(*types.TestMessage))
		}
	}

	return nil
}

func (p *Processor) setContext(ctx sdk.Context) {
	p.lastContext.Store(ctx)
}

// PreAddTxToMempoolFunc checks if a tx has been included in a block. The hash of the tx is used to
// compare with other txs' hash. Only the first tx with such hash is included in the block. This is
// to avoid wasting space on Sisu's block due to duplicated tx submitted by multiple users.
func (p *Processor) PreAddTxToMempoolFunc(txBytes ttypes.Tx) error {
	log.Verbose("checking new tx before adding into mempool....")

	tx, err := p.txDecoder(txBytes)
	if err != nil {
		log.Error("Failed to decode tx")
		return err
	}

	msgs := tx.GetMsgs()
	log.Verbose("PreAddTxToMempoolFunc: msgs length = ", len(msgs))

	for _, msg := range msgs {
		if msg.Route() != types.RouterKey {
			continue
		}

		log.Verbose("PreAddTxToMempoolFunc: Msg type = ", msg.Type())

		switch msg.Type() {
		case types.MsgTypeKeygenWithSigner:
			keygenMsg := msg.(*types.KeygenWithSigner)

			key := fmt.Sprintf("keygen__%s__%d", keygenMsg.Data.KeyType, keygenMsg.Data.Index)
			if err := p.checkAndInsertMempoolTx(key, "keygen"); err != nil {
				return err
			}

		case types.MsgTypeKeygenResultWithSigner:
			resultMsg := msg.(*types.KeygenResultWithSigner)
			// Only do for success case
			if resultMsg.Data.Result == types.KeygenResult_SUCCESS {
				bz, err := resultMsg.Data.Marshal()
				if err != nil {
					return err
				}
				hash := utils.KeccakHash32(string(bz))
				key := fmt.Sprintf("keygenresult__%s__%d__%s", resultMsg.Keygen.KeyType, resultMsg.Keygen.Index, hash)
				if err := p.checkAndInsertMempoolTx(key, "keygen result"); err != nil {
					return err
				}
			}

		case types.MsgTypeTxInWithSigner:
			txIn := msg.(*types.TxInWithSigner).Data
			bz, err := txIn.Marshal()
			if err != nil {
				return err
			}

			hash := utils.KeccakHash32(string(bz))
			if err := p.checkAndInsertMempoolTx(hash, "tx in"); err != nil {
				return err
			}

		case types.MsgTypeTxOutWithSigner:
			txOut := msg.(*types.TxOutWithSigner).Data
			bz, err := txOut.Marshal()
			if err != nil {
				return err
			}

			hash := utils.KeccakHash32(string(bz))
			if err := p.checkAndInsertMempoolTx(hash, "tx out"); err != nil {
				return err
			}

		case types.MsgTypeContractsWithSigner:
			data := msg.(*types.ContractsWithSigner).Data

			bz, err := data.Marshal()
			if err == nil {
				hash := utils.KeccakHash32(string(bz))
				if err := p.checkAndInsertMempoolTx(hash, "contracts"); err != nil {
					return err
				}
			}

		case types.MsgTypeTxOutConfirmationWithSigner:
			data := msg.(*types.TxOutConfirmWithSigner).Data
			bz, err := data.Marshal()
			if err == nil {
				hash := utils.KeccakHash32(string(bz))
				if err := p.checkAndInsertMempoolTx(hash, "tx out confirm"); err != nil {
					return err
				}
			}
		}
	}

	return nil
}

func (p *Processor) checkAndInsertMempoolTx(hash, msgType string) error {
	if p.privateDb.IsMempoolTxExisted(hash) {
		err := fmt.Errorf("%s has been added into the mempool! hash = %s", msgType, hash)
		log.Verbose(err)

		return err
	}

	log.Verbose("Inserting ", msgType, " into the mempool table, hash = ", hash)
	p.privateDb.SaveMempoolTx(hash)

	return nil
}
